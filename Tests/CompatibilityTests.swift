//
//  CompatibilityTests.swift
//  MsgpackSerializationTests iOS
//
//  Created by cherrywoods on 17.12.17.
//

import XCTest
import MessagePack
@testable import MsgpackSerialization

/*
 
 In this file, msgpack generated by msgpack-java is compared to msgpack generated by this framework.
 
 Especially encoded java objects will be decoded to similar swift classes.
 
 */

class CompatibilityTest: XCTestCase {
    
    private let dataPacker = Packer<Data>()
    
    func testCompatibility() {
        
        // we start with a swift forest object with certain properties
        // and a msgpack code containig a similar java object.
        
        let t1 = Tree( height: 34.8, width: 12.43, age: 42, kind: .spruce);
        let t2 = Tree( height: 15.0, width: 14.99, age: 20, kind: .other);
        let t3 = Tree( height: 32.65, width: 20.26, age: 1010, kind: .lime);
        let trees = [ t1, t2, t3 ]
        // this is the swift object
        let forest = Forest(trees: trees, location: "near the city")
        
        // this is the encoding of a java object similar to forest above.
        let msgpackFromJava1 = Data(bytes: [0b10000010, 0b10101000, 0b01101100, 0b01101111, 0b01100011, 0b01100001, 0b01110100, 0b01101001, 0b01101111, 0b01101110, 0b10101101, 0b01101110, 0b01100101, 0b01100001, 0b01110010, 0b00100000, 0b01110100, 0b01101000, 0b01100101, 0b00100000, 0b01100011, 0b01101001, 0b01110100, 0b01111001, 0b10100101, 0b01110100, 0b01110010, 0b01100101, 0b01100101, 0b01110011, 0b10010011, 0b10000100, 0b10100110, 0b01101000, 0b01100101, 0b01101001, 0b01100111, 0b01101000, 0b01110100, 0b11001011, 0b01000000, 0b01000001, 0b01100110, 0b01100110, 0b01100110, 0b01100110, 0b01100110, 0b01100110, 0b10100101, 0b01110111, 0b01101001, 0b01100100, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00101000, 0b11011100, 0b00101000, 0b11110101, 0b11000010, 0b10001111, 0b01011100, 0b10100011, 0b01100001, 0b01100111, 0b01100101, 0b00101010, 0b10100100, 0b01101011, 0b01101001, 0b01101110, 0b01100100, 0b10100110, 0b01010011, 0b01010000, 0b01010010, 0b01010101, 0b01000011, 0b01000101, 0b10000100, 0b10100110, 0b01101000, 0b01100101, 0b01101001, 0b01100111, 0b01101000, 0b01110100, 0b11001011, 0b01000000, 0b00101110, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10100101, 0b01110111, 0b01101001, 0b01100100, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00101101, 0b11111010, 0b11100001, 0b01000111, 0b10101110, 0b00010100, 0b01111011, 0b10100011, 0b01100001, 0b01100111, 0b01100101, 0b00010100, 0b10100100, 0b01101011, 0b01101001, 0b01101110, 0b01100100, 0b10100101, 0b01001111, 0b01010100, 0b01001000, 0b01000101, 0b01010010, 0b10000100, 0b10100110, 0b01101000, 0b01100101, 0b01101001, 0b01100111, 0b01101000, 0b01110100, 0b11001011, 0b01000000, 0b01000000, 0b01010011, 0b00110011, 0b00110011, 0b00110011, 0b00110011, 0b00110011, 0b10100101, 0b01110111, 0b01101001, 0b01100100, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00110100, 0b01000010, 0b10001111, 0b01011100, 0b00101000, 0b11110101, 0b11000011, 0b10100011, 0b01100001, 0b01100111, 0b01100101, 0b11001101, 0b00000011, 0b11110010, 0b10100100, 0b01101011, 0b01101001, 0b01101110, 0b01100100, 0b10100100, 0b01001100, 0b01001001, 0b01001101, 0b01000101, ])
        
        // now we will check, that the msgpack generated from forest is equal to msgpackFromJava
        // and that the deserialization of msgpackFromJava results in an Forest equal to forest
        checkCompatility(forest, binaryMsgpack: msgpackFromJava1)
        
        // here we decode a array of fruits
        // and compare it to a equal list of fruits
        
        let a1 = Apple(color: "green", radius: 1.0)
        let a2 = Apple(color: "red", radius: 1.75)
        let p1 = Pear(color: "brownish yellow", height: 2.0, width: 1.25)
        let p2 = Pear(color: "green", height: 2.6, width: 1.7)
        let b1 = Banana(length: 3.0)
        let b2 = Banana(length: 3.0)
        let b3 = Banana(length: 3.0)
        
        b1.age(); b1.age(); b1.age();
        b2.age()
        
        let array = FruitArrayContainer.value([ FruitContainer.apple(a1),
                                                FruitContainer.apple(a2),
                                                FruitContainer.pear(p1),
                                                FruitContainer.pear(p2),
                                                FruitContainer.banana(b1),
                                                FruitContainer.banana(b2),
                                                FruitContainer.banana(b3) ])
        
        let msgpackFromJava2 = Data(bytes: [0b10010111, 0b10000010, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100101, 0b01100111, 0b01110010, 0b01100101, 0b01100101, 0b01101110, 0b10100110, 0b01110010, 0b01100001, 0b01100100, 0b01101001, 0b01110101, 0b01110011, 0b11001011, 0b00111111, 0b11110000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10000010, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100011, 0b01110010, 0b01100101, 0b01100100, 0b10100110, 0b01110010, 0b01100001, 0b01100100, 0b01101001, 0b01110101, 0b01110011, 0b11001011, 0b00111111, 0b11111100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10000011, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10101111, 0b01100010, 0b01110010, 0b01101111, 0b01110111, 0b01101110, 0b01101001, 0b01110011, 0b01101000, 0b00100000, 0b01111001, 0b01100101, 0b01101100, 0b01101100, 0b01101111, 0b01110111, 0b10100110, 0b01101000, 0b01100101, 0b01101001, 0b01100111, 0b01101000, 0b01110100, 0b11001011, 0b01000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10100101, 0b01110111, 0b01101001, 0b01100100, 0b01110100, 0b01101000, 0b11001011, 0b00111111, 0b11110100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10000011, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100101, 0b01100111, 0b01110010, 0b01100101, 0b01100101, 0b01101110, 0b10100110, 0b01101000, 0b01100101, 0b01101001, 0b01100111, 0b01101000, 0b01110100, 0b11001011, 0b01000000, 0b00000100, 0b11001100, 0b11001100, 0b11001100, 0b11001100, 0b11001100, 0b11001101, 0b10100101, 0b01110111, 0b01101001, 0b01100100, 0b01110100, 0b01101000, 0b11001011, 0b00111111, 0b11111011, 0b00110011, 0b00110011, 0b00110011, 0b00110011, 0b00110011, 0b00110011, 0b10000010, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100101, 0b01100010, 0b01101100, 0b01100001, 0b01100011, 0b01101011, 0b10100110, 0b01101100, 0b01100101, 0b01101110, 0b01100111, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10000010, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100101, 0b01100010, 0b01110010, 0b01101111, 0b01110111, 0b01101110, 0b10100110, 0b01101100, 0b01100101, 0b01101110, 0b01100111, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10000010, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100110, 0b01111001, 0b01100101, 0b01101100, 0b01101100, 0b01101111, 0b01110111, 0b10100110, 0b01101100, 0b01100101, 0b01101110, 0b01100111, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, ] )
        
        checkCompatility(array, binaryMsgpack: msgpackFromJava2)
        
        // a map with banans as values
        
        let dictionary2 = StringAndBananaDictionaryContainer.value([ "a verry old banana" : b1,
                                                                     "an old banana" : b2,
                                                                     "a banana" : b3 ])
        
        let msgpackFromJava5 = Data(bytes: [0b10000011, 0b10101101, 0b01100001, 0b01101110, 0b00100000, 0b01101111, 0b01101100, 0b01100100, 0b00100000, 0b01100010, 0b01100001, 0b01101110, 0b01100001, 0b01101110, 0b01100001, 0b10000010, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100101, 0b01100010, 0b01110010, 0b01101111, 0b01110111, 0b01101110, 0b10100110, 0b01101100, 0b01100101, 0b01101110, 0b01100111, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10110010, 0b01100001, 0b00100000, 0b01110110, 0b01100101, 0b01110010, 0b01110010, 0b01111001, 0b00100000, 0b01101111, 0b01101100, 0b01100100, 0b00100000, 0b01100010, 0b01100001, 0b01101110, 0b01100001, 0b01101110, 0b01100001, 0b10000010, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100101, 0b01100010, 0b01101100, 0b01100001, 0b01100011, 0b01101011, 0b10100110, 0b01101100, 0b01100101, 0b01101110, 0b01100111, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b10101000, 0b01100001, 0b00100000, 0b01100010, 0b01100001, 0b01101110, 0b01100001, 0b01101110, 0b01100001, 0b10000010, 0b10100101, 0b01100011, 0b01101111, 0b01101100, 0b01101111, 0b01110010, 0b10100110, 0b01111001, 0b01100101, 0b01101100, 0b01101100, 0b01101111, 0b01110111, 0b10100110, 0b01101100, 0b01100101, 0b01101110, 0b01100111, 0b01110100, 0b01101000, 0b11001011, 0b01000000, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, ])
        
        checkCompatility(dictionary2, binaryMsgpack: msgpackFromJava5)
        
        // decode a dictionary of doubles and strings
        // and compare it to a equal map of doubles wrapped in string keys and strings
        
        let dictionary = DoubleAndStringDictionaryContainer.value([ 13.8889 : "fourteen",
                                                                    55.7763 : "fiftysix",
                                                                    0.234   : "zero" ])
        
        let msgpackFromJava3 = Data(bytes: [0b10000011, 0b10100111, 0b00110001, 0b00110011, 0b00101110, 0b00111000, 0b00111000, 0b00111000, 0b00111001, 0b10101000, 0b01100110, 0b01101111, 0b01110101, 0b01110010, 0b01110100, 0b01100101, 0b01100101, 0b01101110, 0b10100111, 0b00110101, 0b00110101, 0b00101110, 0b00110111, 0b00110111, 0b00110110, 0b00110011, 0b10101000, 0b01100110, 0b01101001, 0b01100110, 0b01110100, 0b01111001, 0b01110011, 0b01101001, 0b01111000, 0b10100101, 0b00110000, 0b00101110, 0b00110010, 0b00110011, 0b00110100, 0b10100100, 0b01111010, 0b01100101, 0b01110010, 0b01101111, ])
        
        // for this dictionary, msgpack comparison would fail,
        // because the msgpack from java contains string keys.
        checkCompatility(dictionary, binaryMsgpack: msgpackFromJava3, compareMsgpack: false)
        
        // now we decode a simple byte array to data
        // that was encoded from byte[] in java
        let data = Data(bytes: [100, 44, 65, UInt8(bitPattern: -46), 33, 101])
        
        let msgpackFromJava4 = Data(bytes: [0b11000100, 0b00000110, 0b01100100, 0b00101100, 0b01000001, 0b11010010, 0b00100001, 0b01100101, ])
        
        checkCompatility(data, binaryMsgpack: msgpackFromJava4)
        
        // decode a nil value
        let nilValue: Int? = nil
        
        let msgpackFromJava6 = Data(bytes: [0b11000000])
        
        checkCompatility(nilValue, binaryMsgpack: msgpackFromJava6)
        
    }
    
    private func checkCompatility<T>(_ value: T, binaryMsgpack msgpack: Data, compareMsgpack: Bool = true) where T: Codable&Equatable {
        
        // serialize value
        let serialized = try? dataPacker.encode(value)
        XCTAssertNotNil(serialized, "serializing value: \(value) of type \(T.self) failed")
        
        // this code generates a byte array representation
        // that can be coppied to java and used for reverse checks
        printForJava(data: serialized!, type: T.self)
        
        // note that it is not neccessary, that the generated msgpack data is identical to the given msgpack data,
        // it just needs to result in the same values.
        
        // Note that this check is nice to have, but not required. This check will only return true,
        // if e.g. the maps have the same ordering, etc.
        if compareMsgpack { checkMsgpackValueEquality(of: serialized!, and: msgpack) }
        
        // deserialize the given msgpack
        let deserialized = try? dataPacker.decode(toType: T.self, from: msgpack)
        XCTAssertNotNil(deserialized, "deserializing \(msgpack) to type \(T.self) failed")
        
        // check whether the deserialized value is equal to the given value
        XCTAssertEqual(deserialized!, value)
        
    }
    
    private func checkCompatility<T>(_ value: T?, binaryMsgpack msgpack: Data, compareMsgpack: Bool = true) where T: Codable&Equatable {
        
        // serialize value
        let serialized = try? dataPacker.encode(value)
        XCTAssertNotNil(serialized, "serializing value: \(String(describing: value)) of type \(T.self) failed")
        
        // this code generates a byte array representation
        // that can be coppied to java and used for reverse checks
        // printForJava(data: serialized!, type: T.self)
        
        // note that it is not neccessary, that the generated msgpack data is identical to the given msgpack data,
        // it just needs to result in the same values.
        
        // Note that this check is nice to have, but not required. This check will only return true,
        // if e.g. the maps have the same ordering, etc.
        if compareMsgpack { checkMsgpackValueEquality(of: serialized!, and: msgpack) }
        
        // deserialize the given msgpack
        let deserialized = try? dataPacker.decode(toType: T?.self, from: msgpack)
        XCTAssertNotNil(deserialized as Any, "deserializing \(msgpack) to type \(T?.self) failed")
        
        // check whether the deserialized value is equal to the given value
        XCTAssertEqual(deserialized!, value)
        
    }
    
    private func checkMsgpackValueEquality(of msgpack1: Data, and msgpack2: Data) {
        
        let first = try? unpackFirst(msgpack1)
        let second = try? unpackFirst(msgpack2)
        
        XCTAssertNotNil(first, "msgpack1 could not be unpacked")
        XCTAssertNotNil(second, "msgpack2 could not be unpacked")
        
        // /*
        print()
        print(first!)
        print( "<->" )
        print(second!)
        print()
        // */
        
        // this equality is optional
        XCTAssert(compareMsgpack(first!, second!), "the two msgpack values did not contain the same values or had diffrent structures.")
    }
    
    private func printForJava<T>(data: Data, type: T.Type) {
        
        print("Encoding type: \(T.self)")
        var string = "{ "
        for byte in data {
            string += "\(Int8(bitPattern: byte)), "
        }
        string += "};"
        print(string)
        
    }
    
    private func compareMsgpack(_ lhs: MessagePackValue?, _ rhs: MessagePackValue?) -> Bool {
        
        // because msgpack-java seems to have no mechanism to convert doubles,
        // that would fit in a float to floats as this framework does
        // here a comparison accros float and double values is performed
        
        guard lhs != nil && rhs != nil else {
            return lhs == nil && rhs == nil
        }
        
        switch (lhs!, rhs!) {
        case (.nil, .nil):
            return true
        case (.bool(let lhv), .bool(let rhv)):
            return lhv == rhv
        case (.int(let lhv), .int(let rhv)):
            return lhv == rhv
        case (.uint(let lhv), .uint(let rhv)):
            return lhv == rhv
        case (.int(let lhv), .uint(let rhv)):
            return lhv >= 0 && UInt64(lhv) == rhv
        case (.uint(let lhv), .int(let rhv)):
            return rhv >= 0 && lhv == UInt64(rhv)
        case (.float(let lhv), .float(let rhv)):
            return lhv == rhv
        case (.double(let lhv), .double(let rhv)):
            return lhv == rhv
        // because msgpack-java seems to have no mechanism to convert doubles,
        // that would fit in a float to floats as this framework does
        // here a comparison accros float and double values is performed
        case (.float(let lhv), .double(let rhv)):
            return Double(lhv) == rhv
        case (.double(let lhv), .float(let rhv)):
            return lhv == Double(rhv)
        case (.string(let lhv), .string(let rhv)):
            return lhv == rhv
        case (.binary(let lhv), .binary(let rhv)):
            return lhv == rhv
        case (.array(let lhv), .array(let rhv)):
            guard lhv.count == rhv.count else { return false }
            for index in 0..<lhv.count {
                if !compareMsgpack(lhv[index], rhv[index]) {
                    return false
                }
            }
            return true
        case (.map(let lhd), .map(var rhd)):
            for key in lhd.keys {
                if rhd[key] == nil {
                    return false
                }
                if !compareMsgpack(lhd[key], rhd.removeValue(forKey: key)) {
                    return false
                }
            }
            return rhd.isEmpty
        case (.extended(let lht, let lhb), .extended(let rht, let rhb)):
            return lht == rht && lhb == rhb
        default:
            return false
        }
    }
    
}
